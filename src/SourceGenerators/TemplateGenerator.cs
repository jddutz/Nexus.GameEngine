using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Nexus.GameEngine.SourceGenerators
{
    [Generator]
    public class TemplateGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var classDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                    transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
                .Where(static m => m is not null)
                .Collect();

            context.RegisterSourceOutput(classDeclarations, static (spc, source) => Execute(spc, source));
        }

        static bool IsSyntaxTargetForGeneration(SyntaxNode node)
        {
            return node is ClassDeclarationSyntax cds && 
                cds.Modifiers.Any(m => m.IsKind(SyntaxKind.PublicKeyword));
        }

        static ClassToGenerate? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
        {
            var classDeclaration = (ClassDeclarationSyntax)context.Node;
            var symbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration);

            if (symbol == null) return null;

            if (!ImplementsIConfigurable(symbol)) return null;

            var templateProperties = new List<PropertyInfo>();

            foreach (var member in symbol.GetMembers())
            {
                var attribute = member.GetAttributes()
                    .FirstOrDefault(ad => ad.AttributeClass?.Name == "TemplatePropertyAttribute");

                if (attribute != null)
                {
                    string? name = attribute.NamedArguments
                        .FirstOrDefault(kvp => kvp.Key == "Name").Value.Value as string;

                    ITypeSymbol? type = null;

                    if (member is IFieldSymbol field)
                    {
                        type = field.Type;
                        if (name == null)
                        {
                            name = field.Name.TrimStart('_');
                            if (name.Length > 0)
                                name = char.ToUpper(name[0]) + name.Substring(1);
                        }
                    }
                    else if (member is IMethodSymbol method)
                    {
                        if (method.Parameters.Length == 1)
                        {
                            type = method.Parameters[0].Type;
                            if (name == null)
                            {
                                name = method.Name;
                                if (name.StartsWith("Set"))
                                    name = name.Substring(3);
                            }
                        }
                    }

                    if (name != null && type != null)
                    {
                        templateProperties.Add(new PropertyInfo(name, type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)));
                    }
                }
            }

            var baseType = symbol.BaseType;
            bool baseImplementsIConfigurable = baseType != null && ImplementsIConfigurable(baseType);
            
            string baseTemplateName = "Nexus.GameEngine.Components.Template";
            if (baseImplementsIConfigurable && baseType != null)
            {
                var baseNs = baseType.ContainingNamespace.ToDisplayString();
                var baseName = baseType.Name;
                baseTemplateName = $"{baseNs}.{baseName}Template";
            }

            return new ClassToGenerate(
                symbol.Name,
                symbol.ContainingNamespace.ToDisplayString(),
                baseTemplateName,
                templateProperties
            );
        }

        static bool ImplementsIConfigurable(INamedTypeSymbol symbol)
        {
            return symbol.AllInterfaces.Any(i => i.Name == "IConfigurable");
        }

        static void Execute(SourceProductionContext context, System.Collections.Immutable.ImmutableArray<ClassToGenerate?> classesToGenerate)
        {
            var processedNames = new HashSet<string>();

            foreach (var classToGenerate in classesToGenerate)
            {
                if (classToGenerate == null) continue;

                var fullName = $"{classToGenerate.Namespace}.{classToGenerate.Name}";
                if (processedNames.Contains(fullName)) continue;
                processedNames.Add(fullName);

                var sb = new StringBuilder();
                sb.AppendLine("// <auto-generated/>");
                sb.AppendLine("#nullable enable");
                sb.AppendLine();
                sb.AppendLine("using System;");
                sb.AppendLine("using System.Collections.Generic;");
                sb.AppendLine("using Nexus.GameEngine.Components;");
                sb.AppendLine();
                sb.AppendLine($"namespace {classToGenerate.Namespace}");
                sb.AppendLine("{");
                sb.AppendLine($"    public partial record {classToGenerate.Name}Template : {classToGenerate.BaseTemplateName}");
                sb.AppendLine("    {");
                sb.AppendLine($"        public {classToGenerate.Name}Template()");
                sb.AppendLine("        {");
                sb.AppendLine($"            Name = \"{classToGenerate.Name}\";");
                sb.AppendLine("        }");
                sb.AppendLine();
                sb.AppendLine($"        public override Type? ComponentType {{ get; init; }} = typeof({classToGenerate.Name});");
                sb.AppendLine();
                
                foreach (var prop in classToGenerate.Properties)
                {
                    string type = prop.Type;
                    if (!type.EndsWith("?"))
                    {
                        type += "?";
                    }
                    sb.AppendLine($"        public {type} {prop.Name} {{ get; init; }}");
                }

                sb.AppendLine("    }");
                sb.AppendLine("}");

                context.AddSource($"{classToGenerate.Name}Template.g.cs", sb.ToString());
            }
        }

        record ClassToGenerate(
            string Name,
            string Namespace,
            string BaseTemplateName,
            List<PropertyInfo> Properties
        );

        record PropertyInfo(
            string Name,
            string Type
        );
    }
}

namespace System.Runtime.CompilerServices
{
    internal static class IsExternalInit { }
}
