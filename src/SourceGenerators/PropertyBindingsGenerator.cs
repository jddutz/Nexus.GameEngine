using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Nexus.GameEngine.SourceGenerators
{
    [Generator]
    public class PropertyBindingsGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var classDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                    transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
                .Where(static m => m is not null)
                .Collect();

            context.RegisterSourceOutput(classDeclarations, static (spc, source) => Execute(spc, source));
        }

        static bool IsSyntaxTargetForGeneration(SyntaxNode node)
        {
            return node is ClassDeclarationSyntax cds && 
                cds.Modifiers.Any(m => m.IsKind(SyntaxKind.PublicKeyword));
        }

        static ClassToGenerate? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
        {
            var classDeclaration = (ClassDeclarationSyntax)context.Node;
            var symbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration);

            if (symbol == null) return null;

            if (!ImplementsIConfigurable(symbol)) return null;

            var baseType = symbol.BaseType;
            bool baseImplementsIConfigurable = baseType != null && ImplementsIConfigurable(baseType);
            
            string baseBindingsName = "Nexus.GameEngine.Components.PropertyBindings";
            if (baseImplementsIConfigurable && baseType != null)
            {
                var baseNs = baseType.ContainingNamespace.ToDisplayString();
                var baseName = baseType.Name;
                baseBindingsName = $"{baseNs}.{baseName}PropertyBindings";
            }

            var properties = new List<string>();
            foreach (var member in symbol.GetMembers().OfType<IFieldSymbol>())
            {
                if (member.GetAttributes().Any(ad => ad.AttributeClass?.Name == "ComponentPropertyAttribute"))
                {
                    string name = member.Name.TrimStart('_');
                    if (name.Length > 0)
                        name = char.ToUpper(name[0]) + name.Substring(1);
                    properties.Add(name);
                }
            }

            return new ClassToGenerate(
                symbol.Name,
                symbol.ContainingNamespace.ToDisplayString(),
                baseBindingsName,
                properties
            );
        }

        static bool ImplementsIConfigurable(INamedTypeSymbol symbol)
        {
            return symbol.AllInterfaces.Any(i => i.Name == "IConfigurable");
        }

        static void Execute(SourceProductionContext context, System.Collections.Immutable.ImmutableArray<ClassToGenerate?> classesToGenerate)
        {
            var processedNames = new HashSet<string>();

            foreach (var classToGenerate in classesToGenerate)
            {
                if (classToGenerate == null) continue;

                var fullName = $"{classToGenerate.Namespace}.{classToGenerate.Name}";
                if (processedNames.Contains(fullName)) continue;
                processedNames.Add(fullName);

                var sb = new StringBuilder();
                sb.AppendLine("// <auto-generated/>");
                sb.AppendLine("#nullable enable");
                sb.AppendLine();
                sb.AppendLine("using System;");
                sb.AppendLine("using System.Collections.Generic;");
                sb.AppendLine("using Nexus.GameEngine.Components;");
                sb.AppendLine();
                sb.AppendLine($"namespace {classToGenerate.Namespace}");
                sb.AppendLine("{");
                sb.AppendLine($"    public partial class {classToGenerate.Name}PropertyBindings : {classToGenerate.BaseBindingsName}");
                sb.AppendLine("    {");
                
                foreach (var prop in classToGenerate.Properties)
                {
                    sb.AppendLine($"        public IPropertyBinding? {prop} {{ get; init; }}");
                }
                sb.AppendLine();

                sb.AppendLine("        public override IEnumerator<(string propertyName, IPropertyBinding binding)> GetEnumerator()");
                sb.AppendLine("        {");
                
                if (classToGenerate.BaseBindingsName != "Nexus.GameEngine.Components.PropertyBindings")
                {
                    sb.AppendLine("            var baseEnumerator = base.GetEnumerator();");
                    sb.AppendLine("            while (baseEnumerator.MoveNext())");
                    sb.AppendLine("            {");
                    sb.AppendLine("                yield return baseEnumerator.Current;");
                    sb.AppendLine("            }");
                }

                foreach (var prop in classToGenerate.Properties)
                {
                    sb.AppendLine($"            if ({prop} != null) yield return (\"{prop}\", {prop});");
                }
                
                if (classToGenerate.Properties.Count == 0 && classToGenerate.BaseBindingsName == "Nexus.GameEngine.Components.PropertyBindings")
                {
                    sb.AppendLine("            yield break;");
                }

                sb.AppendLine("        }");
                sb.AppendLine("    }");
                sb.AppendLine("}");

                context.AddSource($"{classToGenerate.Name}PropertyBindings.g.cs", sb.ToString());
            }
        }

        record ClassToGenerate(
            string Name,
            string Namespace,
            string BaseBindingsName,
            List<string> Properties
        );
    }
}
