namespace Nexus.GameEngine.GUI;

/// <summary>
/// A UI component that displays text using font atlases.
/// Reuses ImageTextureShader with tint color for text rendering.
/// </summary>
public partial class TextElement(
    IPipelineManager pipelineManager,
    IDescriptorManager descriptorManager)
    : Element(pipelineManager)
{
    // Default text style used when no style is specified
    private static readonly TextStyle DefaultTextStyle = new()
    {
        Font = new FontDefinition
        {
            Name = "Roboto-Regular",
            Source = new EmbeddedTrueTypeFontSource(
                "EmbeddedResources/Fonts/Roboto-Regular.ttf",
                typeof(TextElement).Assembly),
            FontSize = 16,
            CharacterRange = CharacterRange.AsciiPrintable,
            UseSignedDistanceField = false
        },
        Color = new Vector4D<float>(1, 1, 1, 1),
        Alignment = TextAlignment.Left
    };

    public new record Template : RuntimeComponent.Template
    {
        /// <summary>
        /// The text content to display.
        /// </summary>
        public string? Text { get; set; }

        /// <summary>
        /// The text style defining font, color, and alignment.
        /// If not specified, uses default Roboto 16pt white left-aligned text.
        /// </summary>
        public TextStyle? Style { get; set; }

        /// <summary>
        /// Whether the text element should be rendered.
        /// </summary>
        public bool Visible { get; set; } = true;
    }

    // ComponentProperty fields - generator creates public properties with deferred updates
    [ComponentProperty]
    private string _text = string.Empty;

    [ComponentProperty]
    private TextStyle _style = DefaultTextStyle;

    // GPU ResourceManager
    private FontResource? _fontResource;
    private GeometryResource? _geometry;
    private DescriptorSet? _textureDescriptorSet;
    private GeometryDefinition? _currentGeometryDefinition;

    // Properties are auto-generated by source generator from [ComponentProperty] fields above

    // Property change callbacks
    partial void OnTextChanged(string? oldValue)
    {
        if (IsActive())
            RegenerateGeometry();
    }

    partial void OnStyleChanged(TextStyle? oldValue)
    {
        if (IsActive())
        {
            // Release old font and load new one
            if (oldValue != null)
                ResourceManager.Fonts.Release(oldValue.Font);
            
            _fontResource = ResourceManager.Fonts.GetOrCreate(_style.Font);
            UpdateDescriptorSet();
            RegenerateGeometry();
        }
    }

    public bool ShouldRender => IsVisible() && !string.IsNullOrEmpty(_text);
    public uint RenderPriority => 1000; // UI text layer (high priority)

    /// <summary>
    /// Bounding box for text elements. Returns minimal box since these are UI elements.
    /// </summary>
    public Box3D<float> BoundingBox => new(Vector3D<float>.Zero, Vector3D<float>.Zero);

    /// <summary>
    /// Text elements participate in UI render pass (pass 1).
    /// </summary>
    public uint RenderPassFlags => 1u << 1; // UI pass

    /// <summary>
    /// Text elements are leaf components and don't render children.
    /// </summary>
    public bool ShouldRenderChildren => false;

    /// <summary>
    /// Configure the text element using the provided template.
    /// </summary>
    /// <param name="componentTemplate">Template containing configuration data</param>
    protected override void OnLoad(Configurable.Template? componentTemplate)
    {
        base.OnLoad(componentTemplate);

        if (componentTemplate is Template template)
        {
            SetText(template.Text ?? string.Empty);
            SetStyle(template.Style ?? DefaultTextStyle);
            SetVisible(template.Visible);
        }

        // Load font resource
        _fontResource = ResourceManager.Fonts.GetOrCreate(_style.Font);
    }

    protected override void OnActivate()
    {
        base.OnActivate();

        // Create descriptor set for font atlas texture
        UpdateDescriptorSet();

        // Generate initial geometry
        RegenerateGeometry();
    }

    private void UpdateDescriptorSet()
    {
        if (_fontResource == null)
            return;

        var shader = ShaderDefinitions.ImageTexture;
        if (shader.DescriptorSetLayoutBindings == null || shader.DescriptorSetLayoutBindings.Length == 0)
        {
            throw new InvalidOperationException(
                $"Shader {shader.Name} does not define descriptor set layout bindings");
        }

        var layout = descriptorManager.CreateDescriptorSetLayout(shader.DescriptorSetLayoutBindings);
        _textureDescriptorSet = descriptorManager.AllocateDescriptorSet(layout);

        // Update descriptor set with font atlas texture
        descriptorManager.UpdateDescriptorSet(
            _textureDescriptorSet.Value,
            _fontResource.AtlasTexture.ImageView,
            _fontResource.AtlasTexture.Sampler,
            ImageLayout.ShaderReadOnlyOptimal,
            binding: 0);
    }

    private void RegenerateGeometry()
    {
        if (_fontResource == null || string.IsNullOrEmpty(_text))
        {
            // Clear geometry if no text
            if (_currentGeometryDefinition != null)
            {
                ResourceManager.Geometry.Release(_currentGeometryDefinition);
                _currentGeometryDefinition = null;
                _geometry = null;
            }
            return;
        }

        // Generate vertices from text
        var vertices = GenerateTextVertices(_text, _fontResource, Bounds, _style.Alignment);

        // Release old geometry if it exists
        if (_currentGeometryDefinition != null)
        {
            ResourceManager.Geometry.Release(_currentGeometryDefinition);
        }

        // Create new geometry definition
        _currentGeometryDefinition = CreateTextGeometryDefinition(vertices);
        _geometry = ResourceManager.Geometry.GetOrCreate(_currentGeometryDefinition);
    }

    private List<Vertex<Vector2D<float>, Vector2D<float>>> GenerateTextVertices(
        string text,
        FontResource font,
        Rectangle<int> bounds,
        TextAlignment alignment)
    {
        var vertices = new List<Vertex<Vector2D<float>, Vector2D<float>>>();

        // Calculate total text width for alignment
        float totalWidth = 0f;
        foreach (char c in text)
        {
            if (font.Glyphs.TryGetValue(c, out var glyph))
                totalWidth += glyph.Advance;
        }

        // Calculate starting X position based on alignment
        float startX = alignment switch
        {
            TextAlignment.Left => bounds.Origin.X,
            TextAlignment.Center => bounds.Origin.X + (bounds.Size.X - totalWidth) / 2f,
            TextAlignment.Right => bounds.Origin.X + bounds.Size.X - totalWidth,
            _ => bounds.Origin.X
        };

        float cursorX = startX;
        float baselineY = bounds.Origin.Y + font.Ascender;

        foreach (char c in text)
        {
            if (!font.Glyphs.TryGetValue(c, out var glyph))
                continue;

            // Skip whitespace characters (they advance cursor but don't render)
            if (glyph.Width == 0 || glyph.Height == 0)
            {
                cursorX += glyph.Advance;
                continue;
            }

            // Calculate quad positions in screen space
            float x0 = cursorX + glyph.BearingX;
            float y0 = baselineY - glyph.BearingY;
            float x1 = x0 + glyph.Width;
            float y1 = y0 + glyph.Height;

            // Add 4 vertices per character (triangle strip order: TL, BL, TR, BR)
            vertices.Add(new Vertex<Vector2D<float>, Vector2D<float>>
            {
                Position = new Vector2D<float>(x0, y0),
                Attribute1 = glyph.TexCoordMin
            });
            vertices.Add(new Vertex<Vector2D<float>, Vector2D<float>>
            {
                Position = new Vector2D<float>(x0, y1),
                Attribute1 = new Vector2D<float>(glyph.TexCoordMin.X, glyph.TexCoordMax.Y)
            });
            vertices.Add(new Vertex<Vector2D<float>, Vector2D<float>>
            {
                Position = new Vector2D<float>(x1, y0),
                Attribute1 = new Vector2D<float>(glyph.TexCoordMax.X, glyph.TexCoordMin.Y)
            });
            vertices.Add(new Vertex<Vector2D<float>, Vector2D<float>>
            {
                Position = new Vector2D<float>(x1, y1),
                Attribute1 = glyph.TexCoordMax
            });

            cursorX += glyph.Advance;
        }

        return vertices;
    }

    public override IEnumerable<DrawCommand> GetDrawCommands(RenderContext context)
    {
        if (_geometry == null || !_textureDescriptorSet.HasValue || _fontResource == null)
            yield break;

        if (string.IsNullOrEmpty(_text))
            yield break;

        // Each character is 4 vertices, but we need to render them as separate triangle strips
        // Generate one draw command per character
        var glyphCount = _text.Count(c => _fontResource.Glyphs.ContainsKey(c) && 
                                           _fontResource.Glyphs[c].Width > 0 && 
                                           _fontResource.Glyphs[c].Height > 0);

        for (int i = 0; i < glyphCount; i++)
        {
            yield return new DrawCommand
            {
                RenderMask = RenderPasses.UI,
                Pipeline = Pipeline,
                VertexBuffer = _geometry.Buffer,
                FirstVertex = (uint)(i * 4),  // Each glyph has 4 vertices
                VertexCount = 4,
                InstanceCount = 1,
                RenderPriority = (int)RenderPriority,
                PushConstants = new ImageTexturePushConstants
                {
                    UvMin = new Vector2D<float>(0, 0),
                    UvMax = new Vector2D<float>(1, 1),
                    TintColor = _style.Color
                },
                DescriptorSet = _textureDescriptorSet.Value
            };
        }
    }

    protected override void OnDeactivate()
    {
        // Release geometry
        if (_currentGeometryDefinition != null)
        {
            ResourceManager.Geometry.Release(_currentGeometryDefinition);
            _currentGeometryDefinition = null;
            _geometry = null;
        }

        // Release font resource
        if (_style != null)
        {
            ResourceManager.Fonts.Release(_style.Font);
            _fontResource = null;
        }

        // Clear descriptor set
        if (_textureDescriptorSet.HasValue)
        {
            _textureDescriptorSet = null;
        }

        base.OnDeactivate();
    }

    /// <summary>
    /// Creates a geometry definition for dynamically generated text vertices.
    /// </summary>
    private static GeometryDefinition CreateTextGeometryDefinition(List<Vertex<Vector2D<float>, Vector2D<float>>> vertices)
    {
        var vertexArray = vertices.ToArray();
        var hashCode = vertexArray.GetHashCode();
        
        return new GeometryDefinition
        {
            Name = $"TextGeometry_{hashCode}",
            Source = new VertexArrayGeometrySource<Vertex<Vector2D<float>, Vector2D<float>>>(vertexArray)
        };
    }
}
