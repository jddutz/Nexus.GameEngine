using Nexus.GameEngine.Components;
using System.Numerics;

namespace Nexus.GameEngine.Components;

public partial class RectTransform : RuntimeComponent, IRectTransform
{
    [ComponentProperty]
    [TemplateProperty]
    protected Vector2D<float> _position;

    [ComponentProperty]
    [TemplateProperty]
    protected Vector2D<float> _size;

    [ComponentProperty]
    [TemplateProperty]
    protected float _rotation;

    [ComponentProperty]
    [TemplateProperty]
    protected Vector2D<float> _scale = Vector2D<float>.One;

    [ComponentProperty]
    [TemplateProperty]
    protected Vector2D<float> _pivot = Vector2D<float>.Zero; // Top-Left default

    private Matrix4X4<float> _localMatrix = Matrix4X4<float>.Identity;
    private Matrix4X4<float> _worldMatrix = Matrix4X4<float>.Identity;
    // _isDirty is generated by ComponentPropertyGenerator
    private Rectangle<int> _cachedBounds;
    private bool _isBoundsDirty = true;

    public Matrix4X4<float> LocalMatrix
    {
        get
        {
            if (_isDirty) UpdateMatrices();
            return _localMatrix;
        }
    }

    public Matrix4X4<float> WorldMatrix
    {
        get
        {
            if (_isDirty) UpdateMatrices();
            return _worldMatrix;
        }
    }

    // Hook into property changes to set dirty flag
    // These partial methods are generated by ComponentPropertyGenerator
    partial void OnPositionChanged(Vector2D<float> oldValue) => SetDirty();
    partial void OnRotationChanged(float oldValue) => SetDirty();
    partial void OnScaleChanged(Vector2D<float> oldValue) => SetDirty();
    partial void OnSizeChanged(Vector2D<float> oldValue) => SetBoundsDirty();
    partial void OnPivotChanged(Vector2D<float> oldValue) => SetBoundsDirty();
    
    protected void SetDirty()
    {
        _isDirty = true;
        SetBoundsDirty();
        // Invalidate children
        foreach (var child in Children)
        {
            if (child is RectTransform rectTransform)
            {
                rectTransform.SetDirty();
            }
        }
    }

    protected void SetBoundsDirty()
    {
        _isBoundsDirty = true;
    }

    private void UpdateMatrices()
    {
        // Calculate Local Matrix: Scale * Rotation * Translation
        // 2D Rotation is around Z axis
        var rotationMatrix = Matrix4X4.CreateRotationZ(_rotation);
        var scaleMatrix = Matrix4X4.CreateScale(new Vector3D<float>(_scale.X, _scale.Y, 1.0f));
        var translationMatrix = Matrix4X4.CreateTranslation(new Vector3D<float>(_position.X, _position.Y, 0.0f));

        _localMatrix = scaleMatrix * rotationMatrix * translationMatrix;

        // Calculate World Matrix        
        var parent = FindParent<IRectTransform>();
        if (parent == null)
        {
            _worldMatrix = _localMatrix;
        }
        else
        {
            _worldMatrix = _localMatrix * parent.WorldMatrix;
        }

        _isDirty = false;
    }

    public Rectangle<int> GetBounds()
    {
        if (_isBoundsDirty)
        {
            UpdateBounds();
        }
        return _cachedBounds;
    }

    private void UpdateBounds()
    {
        // Calculate corners relative to Pivot
        // TL: -Pivot * Size
        // BR: (1 - Pivot) * Size
        
        var tl = -_pivot * _size;
        var br = (Vector2D<float>.One - _pivot) * _size;
        var tr = new Vector2D<float>(br.X, tl.Y);
        var bl = new Vector2D<float>(tl.X, br.Y);

        // Transform corners to World Space
        var matrix = WorldMatrix;
        
        var vTL = Vector3D.Transform(new Vector3D<float>(tl.X, tl.Y, 0), matrix);
        var vTR = Vector3D.Transform(new Vector3D<float>(tr.X, tr.Y, 0), matrix);
        var vBL = Vector3D.Transform(new Vector3D<float>(bl.X, bl.Y, 0), matrix);
        var vBR = Vector3D.Transform(new Vector3D<float>(br.X, br.Y, 0), matrix);

        // Find AABB
        var minX = Math.Min(Math.Min(vTL.X, vTR.X), Math.Min(vBL.X, vBR.X));
        var maxX = Math.Max(Math.Max(vTL.X, vTR.X), Math.Max(vBL.X, vBR.X));
        var minY = Math.Min(Math.Min(vTL.Y, vTR.Y), Math.Min(vBL.Y, vBR.Y));
        var maxY = Math.Max(Math.Max(vTL.Y, vTR.Y), Math.Max(vBL.Y, vBR.Y));

        _cachedBounds = new Rectangle<int>((int)minX, (int)minY, (int)(maxX - minX), (int)(maxY - minY));
        _isBoundsDirty = false;
    }

    public void SetPosition(Vector2D<float> position)
    {
        if (_position != position)
        {
            var old = _position;
            _position = position;
            OnPositionChanged(old);
        }
    }

    public void SetSize(Vector2D<float> size)
    {
        if (_size != size)
        {
            var old = _size;
            _size = size;
            OnSizeChanged(old);
        }
    }

    public void SetRotation(float rotation)
    {
        if (_rotation != rotation)
        {
            var old = _rotation;
            _rotation = rotation;
            OnRotationChanged(old);
        }
    }

    public void SetScale(Vector2D<float> scale)
    {
        if (_scale != scale)
        {
            var old = _scale;
            _scale = scale;
            OnScaleChanged(old);
        }
    }

    public void SetPivot(Vector2D<float> pivot)
    {
        if (_pivot != pivot)
        {
            var old = _pivot;
            _pivot = pivot;
            OnPivotChanged(old);
        }
    }
}
