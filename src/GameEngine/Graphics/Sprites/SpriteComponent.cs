using Microsoft.Extensions.Logging;
using Nexus.GameEngine.Animation;
using Nexus.GameEngine.Assets;
using Nexus.GameEngine.Components;
using Nexus.GameEngine.Resources;
using Nexus.GameEngine.Graphics.Textures;
using Silk.NET.Maths;
using Silk.NET.OpenGL;

namespace Nexus.GameEngine.Graphics.Sprites;

/// <summary>
/// Component that renders a 2D sprite using a texture asset.
/// Demonstrates integration with the asset management system.
/// </summary>
public partial class SpriteComponent(IAssetService assetService, IResourceManager resourceManager)
    : RuntimeComponent, IRenderable, ISpriteController
{
    /// <summary>
    /// Template for configuring a sprite component with texture asset reference.
    /// </summary>
    public new record Template : RuntimeComponent.Template
    {
        /// <summary>
        /// Reference to the texture asset for this sprite.
        /// </summary>
        public AssetReference<ManagedTexture> Texture { get; init; } = new();

        /// <summary>
        /// The size of the sprite in world units.
        /// </summary>
        public Vector2D<float> Size { get; init; } = Vector2D<float>.One;

        /// <summary>
        /// The tint color applied to the sprite (RGBA as Vector4D<float>).
        /// </summary>
        public Vector4D<float> Tint { get; init; } = Vector4D<float>.One; // White color (1,1,1,1)

        /// <summary>
        /// Whether to flip the sprite horizontally.
        /// </summary>
        public bool FlipX { get; init; } = false;

        /// <summary>
        /// Whether to flip the sprite vertically.
        /// </summary>
        public bool FlipY { get; init; } = false;
    }

    private readonly IAssetService _assetService = assetService ?? throw new ArgumentNullException(nameof(assetService));
    private readonly IResourceManager _resourceManager = resourceManager ?? throw new ArgumentNullException(nameof(resourceManager));
    private Template? _template;
    private ManagedTexture? _loadedTexture;

    // Animated properties for smooth visual transitions
    [ComponentProperty(Duration = AnimationDuration.Normal, Interpolation = InterpolationMode.Linear)]
    private Vector2D<float> _size = Vector2D<float>.One;

    [ComponentProperty(Duration = AnimationDuration.Normal, Interpolation = InterpolationMode.Linear)]
    private Vector4D<float> _tint = Vector4D<float>.One;

    // Boolean properties - instant updates (default: Duration = 0, InterpolationMode.Step)
    [ComponentProperty]
    private bool _flipX = false;

    [ComponentProperty]
    private bool _flipY = false;

    [ComponentProperty]
    private bool _isVisible = true;

    private AssetReference<ManagedTexture>? _textureAsset;

    /// <summary>
    /// Gets the currently loaded texture, if any.
    /// </summary>
    public ManagedTexture? Texture => _loadedTexture;

    // Size, Tint, FlipX, FlipY, and IsVisible properties are generated by ComponentProperty attribute

    /// <summary>
    /// Effects to be applied when rendering this sprite.
    /// </summary>
    public IEnumerable<IRenderEffect> Effects { get; } = Array.Empty<IRenderEffect>();

    protected override void OnConfigure(IComponentTemplate template)
    {
        base.OnConfigure(template);
        _template = template as Template;

        if (_template != null)
        {
            // Initialize properties from template - direct field assignment during configuration
            _size = _template.Size;
            _tint = _template.Tint;
            _flipX = _template.FlipX;
            _flipY = _template.FlipY;
            _textureAsset = _template.Texture;
        }
    }

    protected override void OnActivate()
    {
        base.OnActivate();

        if (_template?.Texture?.AssetId != null && !string.IsNullOrEmpty(_template.Texture.AssetId.Address))
        {
            // Load the texture asset asynchronously
            Task.Run(async () =>
            {
                try
                {
                    Logger?.LogDebug("Loading texture asset: {AssetId}", _template.Texture.AssetId.Address);
                    _loadedTexture = await _assetService.LoadAsync<ManagedTexture>(_template.Texture.AssetId.Address);
                    _template.Texture.CachedAsset = _loadedTexture;

                    Logger?.LogDebug("Successfully loaded texture asset: {AssetId}", _template.Texture.AssetId.Address);
                }
                catch (Exception ex)
                {
                    Logger?.LogError(ex, "Failed to load texture asset: {AssetId}", _template.Texture.AssetId.Address);
                }
            });
        }
    }

    protected override void OnDeactivate()
    {
        if (_template?.Texture?.AssetId != null && _loadedTexture != null)
        {
            // Note: We don't unload the asset here as it might be used by other components
            // The asset service manages the lifecycle based on caching strategy
            _template.Texture.CachedAsset = null;
            _loadedTexture = null;
        }

        base.OnDeactivate();
    }

    public bool ShouldRender => _loadedTexture != null && IsVisible;
    public uint RenderPriority => 400; // UI layer

    /// <summary>
    /// Bounding box for frustum culling based on sprite size.
    /// Returns a minimal box since sprites are typically UI elements that should always render.
    /// </summary>
    public Box3D<float> BoundingBox => new(Vector3D<float>.Zero, Vector3D<float>.Zero); // Minimal box

    /// <summary>
    /// Sprite participates in UI render pass (pass 1).
    /// </summary>
    public uint RenderPassFlags => 1u << 1; // UI pass

    /// <summary>
    /// Sprites are leaf components and don't need to render children.
    /// </summary>
    public bool ShouldRenderChildren => false;

    public IEnumerable<ElementData> GetElements(GL gl, IViewport vp)
    {
        // TODO: Implement sprite rendering by declaring render state requirements
        // For now, just return empty render state
        yield return new ElementData()
        {
            // TODO: update these values
            Vao = 0,
            Vbo = 0,
            Ebo = 0,
            Shader = 0
        };
    }

    // ISpriteController implementation - properties are automatically deferred via ComponentProperty
    public void SetSize(Vector2D<float> size)
    {
        Size = size;
    }

    public void SetSize(float width, float height)
    {
        Size = new Vector2D<float>(width, height);
    }

    public void Scale(float scale)
    {
        Size *= scale;
    }

    public void Scale(float scaleX, float scaleY)
    {
        Size = new Vector2D<float>(Size.X * scaleX, Size.Y * scaleY);
    }

    public void SetTint(Vector4D<float> tint)
    {
        Tint = tint;
    }

    public void SetTint(float r, float g, float b, float a = 1.0f)
    {
        Tint = new Vector4D<float>(r, g, b, a);
    }

    public void SetFlipX(bool flipX)
    {
        FlipX = flipX;
    }

    public void SetFlipY(bool flipY)
    {
        FlipY = flipY;
    }

    public void SetFlip(bool flipX, bool flipY)
    {
        FlipX = flipX;
        FlipY = flipY;
    }

    public void SetVisible(bool visible)
    {
        IsVisible = visible;
    }

    public void SetTexture(AssetReference<ManagedTexture> textureAsset)
    {
        _textureAsset = textureAsset;
        // TODO: Implement texture loading for runtime texture changes
        // This would need to coordinate with the asset loading system
    }
}