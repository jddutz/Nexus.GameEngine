# Property Binding: Leveraging ComponentPropertyUpdater

## Key Insight

`ComponentPropertyUpdater<T>` already handles:
- ✅ Deferred updates (target vs current value)
- ✅ Interpolation support
- ✅ Change detection
- ✅ Efficient equality comparison

We can **leverage this existing infrastructure** for property bindings!

## Simplified Design

Instead of creating a separate binding infrastructure, **extend ComponentPropertyUpdater** to support binding sources.

### Approach 1: Extend ComponentPropertyUpdater with Binding Support

```csharp
public struct ComponentPropertyUpdater<T>
{
    // Existing fields...
    private T _target;
    private InterpolationFunction<T>? _interpolator;
    private bool _hasUpdate;
    
    // NEW: Binding source
    private PropertyBindingSource? _bindingSource;
    
    /// <summary>
    /// Binds this property to a source component's property.
    /// When the source changes, this property updates automatically.
    /// </summary>
    public void BindTo(IComponent sourceComponent, string propertyName, IValueConverter? converter = null)
    {
        _bindingSource = new PropertyBindingSource(sourceComponent, propertyName, converter);
        
        // Subscribe to source property changes
        if (sourceComponent is IRuntimeComponent runtimeComponent)
        {
            runtimeComponent.PropertyChanged += OnSourcePropertyChanged;
        }
        
        // Initial sync
        SyncFromSource();
    }
    
    /// <summary>
    /// Unbinds from the source property.
    /// </summary>
    public void Unbind()
    {
        if (_bindingSource?.SourceComponent is IRuntimeComponent runtimeComponent)
        {
            runtimeComponent.PropertyChanged -= OnSourcePropertyChanged;
        }
        _bindingSource = null;
    }
    
    private void OnSourcePropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (e.PropertyName == _bindingSource?.PropertyName)
        {
            SyncFromSource();
        }
    }
    
    private void SyncFromSource()
    {
        if (_bindingSource == null) return;
        
        var sourceValue = _bindingSource.GetValue();
        if (sourceValue is T typedValue)
        {
            // Use existing Set logic (handles deferred updates, interpolation, etc.)
            // Note: We can't call Set directly since we need ref to current value
            _target = typedValue;
            _hasUpdate = true;
        }
    }
}

internal class PropertyBindingSource
{
    public IComponent SourceComponent { get; }
    public string PropertyName { get; }
    public IValueConverter? Converter { get; }
    private PropertyInfo? _propertyInfo;
    
    public PropertyBindingSource(IComponent sourceComponent, string propertyName, IValueConverter? converter)
    {
        SourceComponent = sourceComponent;
        PropertyName = propertyName;
        Converter = converter;
        _propertyInfo = sourceComponent.GetType().GetProperty(propertyName);
    }
    
    public object? GetValue()
    {
        var value = _propertyInfo?.GetValue(SourceComponent);
        return Converter?.Convert(value, typeof(T)) ?? value;
    }
}
```

**Problem**: `ComponentPropertyUpdater` is a struct, can't hold reference to event subscriptions (memory leak risk).

### Approach 2: Generate Binding Methods on Component (BETTER)

Since the source generator already creates `Set{PropertyName}()` methods, we can **generate additional binding setup methods**:

```csharp
// Generated by ComponentPropertyGenerator
partial class HealthBar
{
    // Existing generated code...
    private ComponentPropertyUpdater<float> _healthState;
    public float Health => _health;
    public void SetHealth(float value, InterpolationFunction<float>? interpolator = null) { ... }
    
    // NEW: Generated binding setup method
    public void BindHealth(IComponent sourceComponent, string sourceProperty, IValueConverter? converter = null)
    {
        // Find property info
        var sourcePropInfo = sourceComponent.GetType().GetProperty(sourceProperty);
        if (sourcePropInfo == null)
        {
            Logger?.LogWarning($"Property {sourceProperty} not found on {sourceComponent.GetType().Name}");
            return;
        }
        
        // Subscribe to changes if source supports PropertyChanged
        if (sourceComponent is IRuntimeComponent runtimeSource)
        {
            void OnSourceChanged(object? sender, PropertyChangedEventArgs e)
            {
                if (e.PropertyName == sourceProperty)
                {
                    var sourceValue = sourcePropInfo.GetValue(sourceComponent);
                    var convertedValue = converter?.Convert(sourceValue, typeof(float)) ?? sourceValue;
                    if (convertedValue is float floatValue)
                    {
                        SetHealth(floatValue); // Use existing Set method!
                    }
                }
            }
            
            runtimeSource.PropertyChanged += OnSourceChanged;
            
            // Store subscription for cleanup
            _healthBindingCleanup = () => runtimeSource.PropertyChanged -= OnSourceChanged;
        }
        
        // Initial sync
        var initialValue = sourcePropInfo.GetValue(sourceComponent);
        var convertedInitial = converter?.Convert(initialValue, typeof(float)) ?? initialValue;
        if (convertedInitial is float floatValue)
        {
            SetHealth(floatValue);
        }
    }
    
    private Action? _healthBindingCleanup;
}
```

## Concise Template Syntax Using Generated Methods

With the generated `Bind{PropertyName}()` methods, we can use **deferred initialization**:

```csharp
public partial class HealthBar : RuntimeComponent
{
    [ComponentProperty]
    protected float _health;
    
    // Component doesn't know about bindings at design time
}

// Template uses post-creation binding
var healthBar = new HealthBarTemplate()
{
    // Regular property initialization
    Name = "PlayerHealthBar"
};

// After creation, bind using generated methods (in OnActivate or custom setup)
// This still requires manual code though...
```

**Problem**: Still requires manual binding code. Not declarative.

### Approach 3: Concise Builder with Generated Integration (RECOMMENDED)

Combine the builder pattern with generated helper methods:

```csharp
// Simplified builder syntax using nameof and generics
public static class PropertyBindingExtensions
{
    /// <summary>
    /// Creates a property binding using the target property's ComponentPropertyUpdater.
    /// This integrates with the existing deferred update system.
    /// </summary>
    public static PropertyBinding Bind<TTarget, TSource>(
        string targetProperty,
        IComponent sourceComponent,
        string sourceProperty)
        where TTarget : IRuntimeComponent
    {
        return new PropertyBinding
        {
            TargetProperty = targetProperty,
            SourceProperty = sourceProperty,
            Lookup = new BindingLookup.DirectReference(sourceComponent), // New lookup type
            Mode = BindingMode.OneWay
        };
    }
    
    // Helper for parent lookup (most common case)
    public static PropertyBinding BindToParent<TComponent>(
        this string targetProperty,
        string sourceProperty)
        where TComponent : IComponent
    {
        return new PropertyBinding
        {
            TargetProperty = targetProperty,
            SourceProperty = sourceProperty,
            Lookup = new BindingLookup.ParentType(typeof(TComponent)),
            Mode = BindingMode.OneWay
        };
    }
}

// CONCISE USAGE in templates
new HealthBarTemplate()
{
    PropertyBindings = 
    [
        nameof(HealthBar.Health).BindToParent<HealthSystem>(nameof(HealthSystem.Health)),
        nameof(HealthBar.MaxHealth).BindToParent<HealthSystem>(nameof(HealthSystem.MaxHealth))
    ]
}
```

**Even more concise with static imports**:

```csharp
using static PropertyBindingHelpers;

new HealthBarTemplate()
{
    PropertyBindings = 
    [
        // Ultra-concise: Target, Source Type, Source Property
        Bind<HealthBar, HealthSystem>(nameof(HealthBar.Health), nameof(HealthSystem.Health)),
        Bind<HealthBar, HealthSystem>(nameof(HealthBar.MaxHealth), nameof(HealthSystem.MaxHealth))
    ]
}

// Helper class
public static class PropertyBindingHelpers
{
    public static PropertyBinding Bind<TTarget, TSource>(string targetProp, string sourceProp)
        where TTarget : IRuntimeComponent
        where TSource : IComponent
    {
        return PropertyBinding.For(targetProp)
            .FromParent<TSource>()
            .Property(sourceProp)
            .Build();
    }
}
```

## Ultimate Conciseness: Attribute-Style Syntax

If we want maximum brevity, use tuple syntax:

```csharp
new HealthBarTemplate()
{
    PropertyBindings = 
    [
        (nameof(Health), typeof(HealthSystem), nameof(HealthSystem.Health)),
        (nameof(MaxHealth), typeof(HealthSystem), nameof(HealthSystem.MaxHealth))
    ]
}

// Extension on Template to convert tuples to PropertyBinding
public record Template
{
    private PropertyBinding[]? _propertyBindings;
    
    public PropertyBinding[] PropertyBindings
    {
        get => _propertyBindings ?? [];
        init => _propertyBindings = value;
    }
    
    // Allow tuple assignment
    public (string target, Type sourceType, string source)[] Bindings
    {
        init
        {
            _propertyBindings = value.Select(tuple =>
                PropertyBinding.For(tuple.target)
                    .FromParent(tuple.sourceType)
                    .Property(tuple.source)
                    .Build()
            ).ToArray();
        }
    }
}

// USAGE - even more concise!
new HealthBarTemplate()
{
    Bindings = 
    [
        (nameof(Health), typeof(HealthSystem), nameof(HealthSystem.Health)),
        (nameof(MaxHealth), typeof(HealthSystem), nameof(HealthSystem.MaxHealth))
    ]
}
```

## Comparison of Syntax Options

### Original Builder (Explicit)
```csharp
PropertyBindings = 
[
    PropertyBinding.For(nameof(Health))
        .FromParent<HealthSystem>()
        .Property(nameof(HealthSystem.Health))
        .Build()
]
```
**Lines**: 5 per binding  
**Readability**: ⭐⭐⭐⭐⭐ (very clear)  
**Brevity**: ⭐⭐ (verbose)

### Helper Method (Medium)
```csharp
PropertyBindings = 
[
    Bind<HealthBar, HealthSystem>(nameof(Health), nameof(HealthSystem.Health))
]
```
**Lines**: 1 per binding  
**Readability**: ⭐⭐⭐⭐ (clear with generics knowledge)  
**Brevity**: ⭐⭐⭐⭐ (concise)

### Tuple Syntax (Ultra-Concise)
```csharp
Bindings = 
[
    (nameof(Health), typeof(HealthSystem), nameof(HealthSystem.Health))
]
```
**Lines**: 1 per binding  
**Readability**: ⭐⭐⭐ (requires understanding tuple structure)  
**Brevity**: ⭐⭐⭐⭐⭐ (most concise)

### Extension Method (Fluent)
```csharp
PropertyBindings = 
[
    nameof(Health).BindToParent<HealthSystem>(nameof(HealthSystem.Health))
]
```
**Lines**: 1 per binding  
**Readability**: ⭐⭐⭐⭐ (reads like English)  
**Brevity**: ⭐⭐⭐⭐ (concise)

## Integration with ComponentPropertyUpdater

The key insight is that **bindings just update properties via existing `Set{PropertyName}()` methods**:

```csharp
internal class ActivePropertyBinding
{
    private readonly IComponent _targetComponent;
    private readonly string _targetProperty;
    private readonly MethodInfo _setMethod; // SetHealth, SetMaxHealth, etc.
    
    public ActivePropertyBinding(IComponent target, string targetProp, /* ... */)
    {
        _targetComponent = target;
        _targetProperty = targetProp;
        
        // Find the generated Set method
        _setMethod = target.GetType().GetMethod($"Set{targetProp}");
    }
    
    private void OnSourcePropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (e.PropertyName == _sourceProperty)
        {
            var sourceValue = GetSourceValue();
            
            // Call the generated Set method - this leverages ComponentPropertyUpdater!
            _setMethod.Invoke(_targetComponent, new[] { sourceValue, null });
            //                                                         ^^^^^ interpolator
        }
    }
}
```

This means:
- ✅ Bindings use existing deferred update system
- ✅ Bindings can use interpolation (pass interpolator to Set method)
- ✅ No duplicate code for update management
- ✅ Bindings integrate seamlessly with component lifecycle

## Recommended Approach

**Use tuple syntax for brevity** with **helper methods for complex cases**:

```csharp
// Simple parent binding - ultra concise
new HealthBarTemplate()
{
    Bindings = 
    [
        (nameof(Health), typeof(HealthSystem), nameof(HealthSystem.Health))
    ]
}

// Complex binding - use builder
new TextElementTemplate()
{
    PropertyBindings = 
    [
        PropertyBinding.For(nameof(Text))
            .FromParent<HealthSystem>()
            .Property(nameof(HealthSystem.Health))
            .WithConverter(new FloatToStringConverter())
            .WithFallback("N/A")
            .Build()
    ]
}
```

This gives you:
- ✅ **Concise syntax** for 90% of cases (simple parent bindings)
- ✅ **Full builder** for complex scenarios (converters, validators, etc.)
- ✅ **Leverages existing infrastructure** (ComponentPropertyUpdater)
- ✅ **Type-safe** with nameof()
- ✅ **IntelliSense friendly**

The tuple syntax reduces 5 lines to 1 line for the common case while maintaining full power for complex scenarios!
