# Property Binding: Revised Understanding

## What I Got Wrong

I was creating **new infrastructure** (`_binding0Source`, `OnBinding0PropertyChanged`, `PropertyChanged` event) when we **already have the mechanism** built into ComponentProperty!

## The Existing Infrastructure

### Generated by ComponentPropertyGenerator

For each `[ComponentProperty]`:
```csharp
public partial class HealthSystem : RuntimeComponent
{
    [ComponentProperty]
    protected float _health;
    
    // GENERATED CODE:
    
    // 1. Public getter
    public float Health => _health;
    
    // 2. Setter with deferred updates
    public void SetHealth(float value, InterpolationFunction<float>? interpolator = null) { ... }
    
    // 3. CALLBACK HOOK (the key piece!)
    partial void OnHealthChanged(float oldValue);
    //           ^^^^^^^^^^^^^^^^^^ This is our event system!
}
```

### How Components Use It

Components can override these partial methods:
```csharp
public partial class HealthSystem : RuntimeComponent
{
    [ComponentProperty]
    protected float _health;
    
    // Optionally implement the callback
    partial void OnHealthChanged(float oldValue)
    {
        // This fires whenever Health changes!
        Console.WriteLine($"Health changed from {oldValue} to {Health}");
    }
}
```

## The Corrected Mental Model

### Source Component (Has the Data)
```csharp
public partial class PlayerCharacter : RuntimeComponent
{
    [ComponentProperty]
    protected float _currentHealth;  // Source property
    
    // Generated: OnCurrentHealthChanged(float oldValue)
}
```

### Target Component (Wants the Data)
```csharp
public partial class HealthBar : RuntimeComponent
{
    [ComponentProperty]
    protected float _currentHealth;  // Target property (same name, but could be different)
    
    // Generated: SetCurrentHealth(float value, ...)
}
```

### The Binding (Event Handler)
The binding is just **subscribing to the source's callback and calling the target's setter**:

```csharp
// Conceptually:
playerCharacter.OnCurrentHealthChanged += (oldValue) => 
{
    var newValue = playerCharacter.CurrentHealth;
    healthBar.SetCurrentHealth(newValue);
};
```

## The Problem

**You can't subscribe to partial methods!** They're compile-time hooks, not runtime events.

So we need to:
1. **Extend the generator** to emit actual events (optional, via attribute parameter)
2. **OR** use a different mechanism

## Solution 1: Add Optional Event Generation

Extend ComponentPropertyGenerator to support:
```csharp
[ComponentProperty(NotifyChange = true)]  // <-- New parameter
protected float _currentHealth;

// GENERATES:
public event EventHandler<PropertyChangedEventArgs<float>>? CurrentHealthChanged;

partial void OnCurrentHealthChanged(float oldValue)
{
    CurrentHealthChanged?.Invoke(this, new PropertyChangedEventArgs<float>(oldValue, CurrentHealth));
}
```

Then bindings work:
```csharp
protected override void OnActivate()
{
    base.OnActivate();
    
    var player = this.FindParent<PlayerCharacter>();
    if (player != null)
    {
        // Subscribe to event
        player.CurrentHealthChanged += (s, e) => SetCurrentHealth(e.NewValue);
        
        // Initial sync
        SetCurrentHealth(player.CurrentHealth);
    }
}
```

## Solution 2: Polling in OnUpdate

Components could poll for changes:
```csharp
private float _lastKnownHealth;

protected override void OnUpdate(double deltaTime)
{
    base.OnUpdate(deltaTime);
    
    var player = this.FindParent<PlayerCharacter>();
    if (player != null && player.CurrentHealth != _lastKnownHealth)
    {
        SetCurrentHealth(player.CurrentHealth);
        _lastKnownHealth = player.CurrentHealth;
    }
}
```

**Problem**: Inefficient, scales poorly with many bindings.

## Solution 3: Custom Event Registration (My Preference)

Make bindings **register themselves** with the component, and the component notifies them:

```csharp
// In RuntimeComponent base class
private List<PropertyBinding>? _propertyBindings;

public void RegisterPropertyBinding(PropertyBinding binding)
{
    _propertyBindings ??= new List<PropertyBinding>();
    _propertyBindings.Add(binding);
}

// Generated code for components WITH bindings configured:
partial void OnCurrentHealthChanged(float oldValue)
{
    // Notify all bindings watching this property
    NotifyPropertyBindings(nameof(CurrentHealth), oldValue, CurrentHealth);
}

private void NotifyPropertyBindings<T>(string propertyName, T oldValue, T newValue)
{
    if (_propertyBindings == null) return;
    
    foreach (var binding in _propertyBindings)
    {
        if (binding.SourcePropertyName == propertyName)
        {
            binding.Update(oldValue, newValue);
        }
    }
}
```

## Your Proposed Syntax

```csharp
Bindings = [
    new PropertyBinding(nameof(HealthBar.CurrentHealth))
        .FromNamedObject("PlayerCharacter")
        .GetPropertyValue(nameof(PlayerCharacter.CurrentHealth))
        .AsFormattedString(currentHealthFormat),
]
```

Or:
```csharp
PropertyBindings.CurrentHealth = new PropertyBinding()
    .FromNamedObject("PlayerCharacter")
    .GetPropertyValue(nameof(CurrentHealth))  // Could default to "CurrentHealth"
    .AsFormattedString(currentHealthFormat);
```

### Problem with Second Syntax

`PropertyBindings.CurrentHealth = ...` requires `PropertyBindings` to be a type with a `CurrentHealth` property. 

**Source generator could create this!**

```csharp
// For HealthBarTemplate, generate:
public partial class HealthBarTemplate
{
    public PropertyBindingsConfig PropertyBindings { get; } = new();
    
    public class PropertyBindingsConfig
    {
        // One property per [ComponentProperty] in HealthBar
        public PropertyBinding? CurrentHealth { get; set; }
        public PropertyBinding? MaxHealth { get; set; }
    }
}
```

Then usage:
```csharp
new HealthBarTemplate()
{
    PropertyBindings = 
    {
        CurrentHealth = PropertyBinding.From("PlayerCharacter", nameof(PlayerCharacter.CurrentHealth)),
        MaxHealth = PropertyBinding.From("PlayerCharacter", nameof(PlayerCharacter.MaxHealth))
    }
}
```

**This is beautiful!** Type-safe property names, no string literals for target properties.

## What the Binding Actually Is

A binding is:
1. **Source lookup** (how to find the component)
2. **Source property name** (what property to read)
3. **Optional converter** (how to transform the value)
4. **Automatic target** (implied by which property you're binding)

The binding **is an event handler** that:
- Finds the source component
- Subscribes to its property changes (however that works)
- Calls `Set{TargetProperty}()` when source changes

## Minimal Binding Record

```csharp
public record PropertyBinding
{
    public required string SourceObjectName { get; init; }
    public required string SourcePropertyName { get; init; }
    public IValueConverter? Converter { get; init; }
    
    public static PropertyBinding From(string sourceObject, string sourceProperty)
        => new() { SourceObjectName = sourceObject, SourcePropertyName = sourceProperty };
}
```

## Generated Code (Simplified)

```csharp
// HealthBar.g.cs (generated)
public partial class HealthBar
{
    // Existing ComponentProperty generation...
    public float CurrentHealth => _currentHealth;
    public void SetCurrentHealth(float value, ...) { ... }
    
    // NEW: Binding setup
    private PlayerCharacter? _binding_CurrentHealth_source;
    
    partial void OnActivateBindings()
    {
        // From template: PropertyBindings.CurrentHealth = PropertyBinding.From("PlayerCharacter", "CurrentHealth")
        
        _binding_CurrentHealth_source = ContentManager?.FindComponentByName<PlayerCharacter>("PlayerCharacter");
        if (_binding_CurrentHealth_source != null)
        {
            _binding_CurrentHealth_source.CurrentHealthChanged += OnBinding_CurrentHealth_Changed;
            SetCurrentHealth(_binding_CurrentHealth_source.CurrentHealth); // Initial sync
        }
    }
    
    private void OnBinding_CurrentHealth_Changed(object? sender, PropertyChangedEventArgs<float> e)
    {
        SetCurrentHealth(e.NewValue);
    }
    
    partial void OnDeactivateBindings()
    {
        if (_binding_CurrentHealth_source != null)
        {
            _binding_CurrentHealth_source.CurrentHealthChanged -= OnBinding_CurrentHealth_Changed;
            _binding_CurrentHealth_source = null;
        }
    }
}
```

Much cleaner! The bindings are just **wiring up existing infrastructure**.
