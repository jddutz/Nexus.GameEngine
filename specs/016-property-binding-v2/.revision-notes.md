# Property Binding V2 - Revision Notes

**Date**: December 7, 2025  
**Status**: Research phase completed with simplified architecture

## Key Changes from Original Spec

### 1. **NO SOURCE GENERATORS Required**

**OLD Approach** (overly complex):
- PropertyBindingsGenerator generates `{Component}PropertyBindings` classes
- One property per `[ComponentProperty]`  
- Template has `Bindings = new HealthBarPropertyBindings { Health = ... }`

**NEW Approach** (simplified):
- No generator needed
- Template has `Bindings = [ ... ]` (simple array)
- Use `IPropertyBinding[]` instead of generated classes

```csharp
// OLD (complex):
public class HealthBarTemplate : ComponentTemplate
{
    public HealthBarPropertyBindings Bindings { get; init; } = new() 
    {
        CurrentHealth = PropertyBinding.From("Player", "Health")
    };
}

// NEW (simple):
public class HealthBarTemplate : ComponentTemplate  
{
    public IPropertyBinding[] Bindings { get; init; } = 
    [
        new PropertyBinding<PlayerComponent, string>()
            .FindParent()
            .On(p => p.HealthChanged)
            .GetPropertyValue(p => p.Health)
            .ConvertToString(h => $"Health: {h:F0}")
            .Set(SetText)
    ];
}
```

### 2. **Explicit Setters Instead of Magic**

**What**: Every binding MUST call `.Set(setterMethod)` to specify how to update the target

**Why**: 
- No need to generate setters
- Type-safe at compile time
- Developer explicitly chooses target property
- Compiler enforces via type system (PropertyBinding<TSource, TValue> ‚Üí IPropertyBinding only via .Set())

```csharp
// Component already has setter methods
public void SetText(string value) { Text = value; }
public void SetHealth(float value) { Health = value; }

// Binding explicitly uses them
.Set(SetText)  // ‚Üê Required, type-enforced
```

### 3. **Simple Lookup Strategy**

**OLD** (over-engineered):
- ILookupStrategy interface
- ParentLookup<T>, SiblingLookup<T>, ChildLookup<T> classes
- Strategy pattern for tree navigation

**NEW** (simple):
- Static helper methods in `ComponentLookup` class
- Store as `Func<IComponent, TSource?>` delegate
- Default to FindParent (implicit)

```csharp
// Simple static helpers
public static class ComponentLookup
{
    public static TSource? FindParent<TSource>(IComponent target) { ... }
    public static TSource? FindSibling<TSource>(IComponent target) { ... }
}

// Fluent API stores delegate
private Func<IComponent, TSource?>? _lookupFunc;

public PropertyBinding<TSource, TValue> FindParent()
{
    _lookupFunc = ComponentLookup.FindParent<TSource>;
    return this;
}
```

### 4. **Type Transformation via Generics**

**What**: PropertyBinding<TSource, TValue> where TValue changes as pipeline transforms

**Why**: Compile-time type safety without reflection in hot path

```csharp
// Type changes through pipeline:
new PropertyBinding<PlayerComponent, float>()     // TValue = float (initial)
    .GetPropertyValue(p => p.Health)              // still float
    .ConvertToString(h => $"Health: {h:F0}")      // TValue = string
    .Set(SetText)                                  // IPropertyBinding (terminal)
```

### 5. **Event Subscription via Expression**

**What**: Use `Expression<Func<TSource, EventHandler<>>>` for compile-time event selection

**Why**: 
- Type-safe: `.On(p => p.HealthChanged)` instead of `.On("HealthChanged")`
- Refactoring support
- IntelliSense during template authoring
- Extract EventInfo once, reuse for subscription

```csharp
public PropertyBinding<TSource, TValue> On(
    Expression<Func<TSource, EventHandler<PropertyChangedEventArgs<TValue>>>> eventSelector)
{
    if (eventSelector.Body is MemberExpression { Member: EventInfo eventInfo })
    {
        _eventInfo = eventInfo;
    }
    return this;
}
```

### 6. **Default Behaviors**

**Defaults**:
- Source resolution: `FindParent<TSource>()` (implicit, 90% of cases)
- Event subscription: `PropertyChanged` (generic catch-all)
- Value transformation: NONE - must explicitly call `.GetPropertyValue()` or converters
- Setter: REQUIRED - compiler error if omitted

**Type-Safe Enforcement**:
```csharp
// Template expects IPropertyBinding[]
public IPropertyBinding[] Bindings { get; init; }

// PropertyBinding<TSource, TValue> is NOT IPropertyBinding
// Only .Set() returns IPropertyBinding
// Therefore compiler forces .Set() to be called
```

### 7. **Lifecycle Integration**

**Flow**:
1. **Template** (compile-time): Configure bindings with fluent API
2. **Component.Load()**: Copy `template.Bindings` to `PropertyBindings` list
3. **Component.Activate()**: Iterate bindings, call `Activate(this)` on each
   - Resolve source component
   - Subscribe to event
   - Perform initial value sync
4. **Events fire**: Binding invokes target setter
5. **Component.Deactivate()**: Iterate bindings, call `Deactivate()`
   - Unsubscribe from event
   - Clear source reference

**Simple Implementation**:
```csharp
// Template
public IPropertyBinding[] Bindings { get; init; } = [];

// Component
protected List<IPropertyBinding> PropertyBindings { get; } = new();

protected virtual void LoadPropertyBindings()
{
    PropertyBindings.AddRange(Template?.Bindings ?? []);
}

protected virtual void ActivatePropertyBindings()
{
    foreach (var binding in PropertyBindings)
        binding.Activate(this);
}

protected virtual void DeactivatePropertyBindings()
{
    foreach (var binding in PropertyBindings)
        binding.Deactivate();
}
```

## What to Remove

After new implementation is verified, remove:

- ‚ùå `src/SourceGenerators/PropertyBindingsGenerator.cs`
- ‚ùå Generated `*PropertyBindings.g.cs` files
- ‚ùå `ILookupStrategy` interface (if exists)
- ‚ùå Concrete lookup strategy classes (ParentLookup, etc.)
- ‚ùì `IPropertyBindingDefinition` (assess if still needed)
- ‚ùì `IValueConverter` pattern (assess if `Func<>` delegates suffice)
- ‚ùì `PropertyBindings` abstract base class

## Performance Characteristics

**Compile-time (template creation)**:
- Expression compilation: Once per binding definition
- Type checking: Full compile-time validation

**Load-time (Component.Load)**:
- Array copy: O(n) where n = number of bindings
- Zero allocations (reuse template binding instances)

**Activate-time (Component.Activate)**:
- Lookup: O(tree depth) typically <10 iterations
- Event subscription: One-time reflection call to EventInfo.AddEventHandler
- Initial sync: One property read + one setter call

**Runtime (event firing)**:
- **ZERO REFLECTION** - pure delegate invocations
- Property read: Compiled expression delegate
- Setter call: Direct method delegate
- Overhead: ~0.01ms per property change (equivalent to manual event handler)

## Migration Guide

**Old Pattern** (013-property-binding):
```csharp
Bindings = new HealthBarPropertyBindings
{
    CurrentHealth = PropertyBinding.From("PlayerCharacter", nameof(CurrentHealth))
}
```

**New Pattern** (016-property-binding-v2):
```csharp
Bindings = 
[
    new PropertyBinding<PlayerCharacter, string>()
        .FindParent()  // Optional, this is the default
        .On(p => p.HealthChanged)  // Optional, defaults to PropertyChanged
        .GetPropertyValue(p => p.Health)
        .ConvertToString(h => $"Health: {h:F0}")
        .Set(SetText)  // Required
]
```

## Next Steps

1. ‚úÖ Research complete (this document)
2. üîÑ Update spec.md to reflect simplified user stories
3. üîÑ Update plan.md with revised implementation tasks
4. üîÑ Update quickstart.md with new fluent API examples
5. üîÑ Update data-model.md to remove ILookupStrategy, IPropertyBindingDefinition
6. üîÑ Update contracts/ to reflect simplified interfaces
7. ‚è≥ Begin implementation with updated architecture
