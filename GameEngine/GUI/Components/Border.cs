using Silk.NET.Maths;

using Microsoft.Extensions.Logging;

using Nexus.GameEngine.Animation;
using Nexus.GameEngine.Components;

namespace Nexus.GameEngine.GUI.Components;

/// <summary>
/// Component Template
/// </summary>
public record BorderTemplate
{
}

/// <summary>
/// Runtime border component that implements event-driven rendering behavior.
/// Templates configure the visual properties, runtime components subscribe to events and implement behavior.
/// </summary>
public partial class Border()
    : RuntimeComponent
{
    // ComponentProperty fields - generator creates public properties with deferred updates
    [ComponentProperty]
    private BorderStyle _style = BorderStyle.Rectangle;

    [ComponentProperty(Duration = AnimationDuration.Normal, Interpolation = InterpolationMode.CubicEaseInOut)]
    private Vector4D<float> _backgroundColor = Vector4D<float>.Zero; // Transparent (0,0,0,0)

    [ComponentProperty(Duration = AnimationDuration.Normal, Interpolation = InterpolationMode.CubicEaseInOut)]
    private Vector4D<float> _borderColor = new(0, 0, 0, 1); // Black (0,0,0,1)

    [ComponentProperty]
    private Thickness _borderThickness = new(0);

    [ComponentProperty(Duration = AnimationDuration.Normal, Interpolation = InterpolationMode.Linear)]
    private float _cornerRadius = 0f;

    [ComponentProperty]
    private string _backgroundImage = string.Empty;

    [ComponentProperty]
    private string _borderImage = string.Empty;

    [ComponentProperty]
    private bool _isVisible = true;

    [ComponentProperty(Duration = AnimationDuration.Normal, Interpolation = InterpolationMode.Linear)]
    private float _opacity = 1.0f;

    // Properties are auto-generated by source generator from [ComponentProperty] fields above

    // Property change callbacks to trigger render updates
    partial void OnStyleChanged(BorderStyle oldValue) => OnRenderPropertiesChanged();
    partial void OnBackgroundColorChanged(Vector4D<float> oldValue) => OnRenderPropertiesChanged();
    partial void OnBorderColorChanged(Vector4D<float> oldValue) => OnRenderPropertiesChanged();
    partial void OnBorderThicknessChanged(Thickness oldValue) => OnRenderPropertiesChanged();
    partial void OnCornerRadiusChanged(float oldValue) => OnRenderPropertiesChanged();
    partial void OnBackgroundImageChanged(string oldValue) => OnRenderPropertiesChanged();
    partial void OnBorderImageChanged(string oldValue) => OnRenderPropertiesChanged();
    partial void OnIsVisibleChanged(bool oldValue) => OnRenderPropertiesChanged();
    partial void OnOpacityChanged(float oldValue)
    {
        // Clamp opacity to 0-1 range
        if (_opacity < 0.0f) _opacity = 0.0f;
        if (_opacity > 1.0f) _opacity = 1.0f;
        OnRenderPropertiesChanged();
    }

    /// <summary>
    /// Event fired when render properties change.
    /// </summary>
    public event EventHandler? RenderPropertiesChanged;

    /// <summary>
    /// Activate phase - Subscribe to required events.
    /// No interfaces needed - components self-register for events they care about.
    /// </summary>
    protected override void OnActivate()
    {
        // Border components are rendered through the IRenderable interface
        // when the renderer walks the component tree
    }

    /// <summary>
    /// Render event handler - Implements actual rendering behavior.
    /// Called automatically when the renderer walks the component tree via viewports.
    /// </summary>
    private void OnRender(object sender, EventArgs e)
    {
        if (!IsVisible || Opacity <= 0.0f)
            return;

        switch (Style)
        {
            case BorderStyle.Rectangle:
                RenderRectangle();
                break;

            case BorderStyle.RoundedRect:
                RenderRoundedRectangle();
                break;

            case BorderStyle.Image:
                RenderImage();
                break;

            case BorderStyle.NinePatch:
                RenderNinePatch();
                break;
        }
    }

    private void RenderRectangle()
    {
        // TODO: Implement rectangle rendering using IGraphicsRenderContext.DrawRectangle
        // This will require:
        // 1. Get component bounds from Transform
        // 2. Draw background rectangle if BackgroundColor != Transparent
        // 3. Draw border rectangles if BorderThickness > 0

        // Placeholder implementation
        Logger?.LogDebug("Rendering Rectangle Border: Background={BackgroundColor}, Border={BorderColor}, Thickness={BorderThickness}", _backgroundColor, _borderColor, _borderThickness);
    }

    private void RenderRoundedRectangle()
    {
        // TODO: Future implementation for rounded corners
        Logger?.LogDebug("Rendering RoundedRect Border (not implemented): CornerRadius={CornerRadius}", _cornerRadius);
    }

    private void RenderImage()
    {
        // TODO: Future implementation for image backgrounds
        Logger?.LogDebug("Rendering Image Border (not implemented): Image={BackgroundImage}", _backgroundImage);
    }

    private void RenderNinePatch()
    {
        // TODO: Future implementation for ninepatch borders
        Logger?.LogDebug("Rendering NinePatch Border (not implemented): Image={BorderImage}", _borderImage);
    }

    private void OnRenderPropertiesChanged()
    {
        RenderPropertiesChanged?.Invoke(this, EventArgs.Empty);
    }
}
